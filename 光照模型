struct DirLight {//平行光
    vec3 direction;//方向

    vec3 ambient;//环境光分量
    vec3 diffuse;//漫反射光分量
    vec3 specular;//镜面反射光分量
};  

vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir)
{//平行光 光照模型 light:平行光  normal:法向量 viewDir：视线方向向量
    vec3 lightDir = normalize(-light.direction);
    // 漫反射着色
    float diff = max(dot(normal, lightDir), 0.0);
    // 镜面光着色
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);//material.shininess反光度越高，反射光的能力越强，散射得越少，高光点就会越小
    // 合并结果
    vec3 ambient  = light.ambient  * vec3(texture(material.diffuse, TexCoords));//环境光分量
    vec3 diffuse  = light.diffuse  * diff * vec3(texture(material.diffuse, TexCoords));//漫反射光分量 material.diffuse:漫反射贴图
    vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));//镜面反射光分量 material.specular:镜面反射贴图
    return (ambient + diffuse + specular);
}

struct PointLight {//点光源
    vec3 position;//位置

    float constant;//光线衰减常量
    float linear;//光线衰减一次项
    float quadratic;//光线衰减二次项

    vec3 ambient;//环境光分量
    vec3 diffuse;//漫反射光分量
    vec3 specular;//镜面反射光分量
};  

vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{//点光源 光照模型 light:点光源 normal:法线 fragPos:片元位置  viewDir:视线方向向量
    vec3 lightDir = normalize(light.position - fragPos);
    // 漫反射着色
    float diff = max(dot(normal, lightDir), 0.0);
    // 镜面光着色
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // 衰减
    float distance    = length(light.position - fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + 
                 light.quadratic * (distance * distance));//计算衰减值    
    // 合并结果
    vec3 ambient  = light.ambient  * vec3(texture(material.diffuse, TexCoords));//环境光分量
    vec3 diffuse  = light.diffuse  * diff * vec3(texture(material.diffuse, TexCoords));//漫反射光分量
    vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));//镜面反射光分量
    ambient  *= attenuation;
    diffuse  *= attenuation;
    specular *= attenuation;
    return (ambient + diffuse + specular);
}

struct SpotLight {//聚光灯
    vec3 position;//位置
    vec3 direction;//方向
    float cutOff;//内圆锥余弦值
    float outerCutOff;//外圆锥余弦值
  
    float constant;//光线衰减常量
    float linear;//光线衰减一次项
    float quadratic;//光线衰减二次项
  
    vec3 ambient;//环境光分量
    vec3 diffuse;//漫反射光分量
    vec3 specular;//镜面反射光分量       
};

vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{//聚光灯 光照模型 为了创建一种看起来边缘平滑的聚光，我们需要模拟聚光有一个内圆锥(Inner Cone)和一个外圆锥(Outer Cone)。
//来让光从内圆锥逐渐减暗，直到外圆锥的边界。
    vec3 lightDir = normalize(light.position - fragPos);
    // 漫反射着色
    float diff = max(dot(normal, lightDir), 0.0);
    // 镜面光着色
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // 衰减
    float distance = length(light.position - fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance)); //计算衰减值   
    // 聚光灯强度
    float theta = dot(lightDir, normalize(-light.direction)); 
    float epsilon = light.cutOff - light.outerCutOff;
    float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);//保证强度值不会在[0, 1]区间之外
    // 合并结果
    vec3 ambient = light.ambient * vec3(texture(material.diffuse, TexCoords));
    vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, TexCoords));
    vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));
    ambient *= attenuation * intensity;
    diffuse *= attenuation * intensity;
    specular *= attenuation * intensity;
    return (ambient + diffuse + specular);
}
