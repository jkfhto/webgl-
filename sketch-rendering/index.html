<!DOCTYPE html>
<html lang="en">
	<head>
		<title>素描效果</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>

	<body>
        <script id="depth-vert" type="x-shader/x-vertex">
			varying vec2 vUv;

			void main() {
				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			}
		</script>
		<script id="depth-frag" type="x-shader/x-fragment">
			#include <packing>

			varying vec2 vUv;
			uniform sampler2D tDiffuse;
			uniform sampler2D tDepth;
			uniform float cameraNear;
			uniform float cameraFar;

            float LinearizeDepth(float depth, float near, float far)//将屏幕空间中非线性的深度值变换至线性深度值
			{
			    float z = depth * 2.0 - 1.0; // back to NDC
			    // return z;
			    return (2.0 * near * far) / (far + near - z * (far - near)) / far;//除以far转到[0-1]
			}

			float readDepth3 (sampler2D depthSampler, vec2 coord) {// 将深度转到线性空间[0-1],默认是非线性的接近1.0
				float fragCoordZ = texture2D(depthSampler, coord).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );
			}

			float readDepth (float fragCoordZ,float cameraNear,float cameraFar) {//将深度从非线性转为线性表示
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );
			}

			void main() {//cameraNear和cameraFar 相对于物体来说太大 会导致深度depth接近于1
				//float depth = readDepth(gl_FragCoord.z,cameraNear,cameraFar);
                float depth = LinearizeDepth(gl_FragCoord.z,cameraNear,cameraFar);
				gl_FragColor.rgb = vec3(depth);
				gl_FragColor.a = 1.0;
			}
		</script>
		<script id="outline-vert" type="x-shader/x-vertex">
			varying vec2 vUv;

			void main() {
				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			}
		</script>
		<script id="outline-frag" type="x-shader/x-fragment">

			varying vec2 vUv;
			uniform vec2 uResolution;
			uniform sampler2D depthtexture;
			uniform sampler2D normaltexture;
			uniform sampler2D hatchtexture;

            float planeDistance(const in vec3 positionA, const in vec3 normalA, 
                    const in vec3 positionB, const in vec3 normalB) {
			    vec3 positionDelta = positionB-positionA;
			    float planeDistanceDelta = max(abs(dot(positionDelta, normalA)), abs(dot(positionDelta, normalB)));
			    return planeDistanceDelta;
			}

			void main() {
			    float depthCenter = texture2D(depthtexture, vUv).r;
			    float px = 1.0/uResolution.x;//计算每个像素大小的uv坐标
			    vec3 leftpos = vec3(vUv.s - px, vUv.t, 1.0 - texture2D(depthtexture, vec2(vUv.s - px, vUv.t)).r);
			    vec3 rightpos = vec3(vUv.s + px, vUv.t, 1.0 - texture2D(depthtexture, vec2(vUv.s + px, vUv.t)).r);
			    vec3 uppos = vec3(vUv.s, vUv.t - px, 1.0 - texture2D(depthtexture, vec2(vUv.s, vUv.t - px)).r);
			    vec3 downpos = vec3(vUv.s, vUv.t + px, 1.0 - texture2D(depthtexture, vec2(vUv.s, vUv.t + px)).r);
			    vec3 leftnor = texture2D(normaltexture, vec2(vUv.s - px, vUv.t)).xyz;
			    vec3 rightnor = texture2D(normaltexture, vec2(vUv.s + px, vUv.t)).xyz;
			    vec3 upnor = texture2D(normaltexture, vec2(vUv.s, vUv.t - px)).xyz;
			    vec3 downnor = texture2D(normaltexture, vec2(vUv.s, vUv.t + px)).xyz;
			    vec2 planeDist = vec2(
			    planeDistance(leftpos, leftnor, rightpos, rightnor),
			    planeDistance(uppos, upnor, downpos, downnor));

			    float planeEdge = 2.5 * length(planeDist);
			    planeEdge = 1.0 - 0.5 * smoothstep(0.0, depthCenter, planeEdge);
			    float normEdge = max(length(leftnor - rightnor), length(upnor - downnor));
			    normEdge = 1.0 - 0.5 * smoothstep(0.0, 0.5, normEdge); 
			    float edge= planeEdge * normEdge;
			    vec4 hatch = texture2D(hatchtexture, vUv);
			    gl_FragColor = vec4(vec3(hatch * edge), 1.0);
			    //gl_FragColor = vec4(vec3( edge), 1.0);
			}
		</script>
		 <script id="sketch-vert" type="x-shader/x-vertex">
			varying vec2 vUv;

			void main() {
				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			}
		</script>
		<script id="sketch-frag" type="x-shader/x-fragment">
			varying vec2 vUv;
			uniform sampler2D bakedshadow;
			uniform sampler2D hatch0;//是hatch0,hatch1,hatch2 3中纹理中最亮的 对应于场景中最亮的部分
			uniform sampler2D hatch1;//是hatch0,hatch1,hatch2 3中纹理中中间亮度的 对应于场景中比较亮的部分
			uniform sampler2D hatch2;//是hatch0,hatch1,hatch2 3中纹理中最暗的 对应于场景中最暗的部分

            float shade(float shading, vec2 uv) {//根据场景中物体的不同灰度 采样不同的纹理实现素描效果
				float shadingFactor;
				float stepSize = 1.0 / 3.0;
				float alpha = 0.0;
				float scaleWhite = 0.0;//基准颜色
				float scaleHatch0 = 0.0;
				float scaleHatch1 = 0.0;
				float scaleHatch2 = 0.0;
				if (shading <= stepSize) {//场景中最暗的区域 使用hatch1,hatch2
				    alpha = 3.0 * shading;//限制在[0-1]
				    scaleHatch1 = alpha;
				    scaleHatch2 = 1.0 - alpha;
				}
				else if (shading > stepSize && shading <= 2.0 * stepSize) {//场景中中间亮的区域 使用hatch0,hatch1
				    alpha = 3.0 * (shading - stepSize);//限制在[0-1]
				    scaleHatch0 = alpha;
				    scaleHatch1 = 1.0 - alpha;
				}
				else if (shading > 2.0 * stepSize) {//场景中最亮的区域 使用hatch0
				    alpha = 3.0 * (shading - stepSize * 2.0);//限制在[0-1]
				    scaleWhite = alpha;
				    scaleHatch0 = 1.0 - alpha;
				}
				shadingFactor = scaleWhite + 
				    scaleHatch0 * texture2D(hatch0, uv).r +
				    scaleHatch1 * texture2D(hatch1, uv).r +
				    scaleHatch2 * texture2D(hatch2, uv).r;
				return shadingFactor;
            }

			void main() {
				vec2 uv = vUv * 15.0;//uv扩大 相当于设置纹理repeat参数的值
				vec2 uv2 = vUv.yx * 10.0;//旋转获取交叉采样
				float shading = texture2D(bakedshadow, vUv).r + 0.1;
				float crossedShading = shade(shading, uv) * shade(shading, uv2) * 0.6 + 0.4;//* 0.6 整体变亮 (+ 0.4):限制在[0-1]
				//crossedShading = shade(shading, uv)* 0.6 + 0.4;//使用[hatch_3-hatch_3.jpg]的纹理不需要旋转
				gl_FragColor = vec4(vec3(crossedShading), 1.0);
			}
		</script>
		<script src="../js/three.js"></script>
        <script src="../js/OrbitControls.js"></script>
		<script src="../js/Detector.js"></script>
		<script src="../js/stats.min.js"></script>
        <script type="text/javascript" src="js/main.js"></script>

	</body>
</html>
